<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Gym Bros</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.24.7/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.2/dist/chart.umd.min.js"></script>
  
  <!-- Firebase SDKs -->
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script>
        <script>
          if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
              navigator.serviceWorker.register('/service-worker.js')
                .then(registration => {
                  console.log('Service Worker registered with scope:', registration.scope);
                })
                .catch(error => {
                  console.log('Service Worker registration failed:', error);
                });
            });
          }
        </script>
</head>
<body class="bg-gray-100">
  <div id="root"></div>

  <script type="text/babel">
    // =========== FIREBASE INITIALIZATION ===========
    const firebaseConfig = {
      apiKey: "AIzaSyBZRREDgLxgxYpNKtUHZkswej5ZrWx8h3g",
      authDomain: "workout-tracker-app-b6cd8.firebaseapp.com",
      databaseURL: "https://workout-tracker-app-b6cd8-default-rtdb.europe-west1.firebasedatabase.app",
      projectId: "workout-tracker-app-b6cd8",
      storageBucket: "workout-tracker-app-b6cd8.appspot.com",
      messagingSenderId: "331327932745",
      appId: "1:331327932745:web:c3a1e7b9973c5d5ee3f298",
      measurementId: "G-6E83DF6LHH"
    };

    if (!firebase.apps.length) {
        firebase.initializeApp(firebaseConfig);
    }
    
    const auth = firebase.auth();
    const db = firebase.database();
    const { useState, useEffect, useRef } = React;

    const debounce = (func, delay) => {
      let timeout;
      return (...args) => {
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(this, args), delay);
      };
    };

    // =========== AUTHENTICATION COMPONENT ===========
    const AuthPage = () => {
        const [isRegistering, setIsRegistering] = useState(false);
        const [data, setData] = useState({ password: '', username: '' });
        const [error, setError] = useState('');

        const handleAuthAction = async () => {
            setError('');
            if (!data.username || !data.password) {
                setError('Please fill in all fields.');
                return;
            }
            const email = data.username.toLowerCase().trim() + '@g.com';
            const username = data.username.trim().toLowerCase();

            if (isRegistering) {
                try {
                    const usernameSnapshot = await db.ref(`usernames/${username}`).once('value');
                    if (usernameSnapshot.exists()) {
                        setError('Username already taken. Please choose another one.');
                        return;
                    }
                    
                    const userCredential = await auth.createUserWithEmailAndPassword(email, data.password);
                    const user = userCredential.user;
                    
                    await db.ref(`users/${user.uid}/profile`).set({ username: username, email: email, firstName: '', lastName: '', dateOfBirth: '', shareWorkouts: true }); // Added shareWorkouts
                    await db.ref(`usernames/${username}`).set({ uid: user.uid });

                } catch (err) {
                    setError(err.message);
                }
            } else {
                auth.signInWithEmailAndPassword(email, data.password)
                    .catch(err => setError('Invalid username or password.'));
            }
        };

        return (
            <div className="container mx-auto p-4 max-w-md mt-10">
                <h1 className="text-3xl font-bold mb-6 text-center">Gym Bros</h1>
                <div className="p-6 bg-white rounded-lg shadow-lg">
                    <h2 className="text-2xl font-semibold mb-4 text-center">{isRegistering ? 'Register' : 'Login'}</h2>
                    {error && <p className="text-red-500 mb-4 text-center">{error}</p>}
                    <div className="space-y-4">
                        <input
                            type="text"
                            placeholder="Username"
                            value={data.username}
                            onChange={(e) => setData({ ...data, username: e.target.value })}
                            className="w-full p-3 border rounded-lg focus:ring-2 focus:ring-blue-500"
                        />
                        <input
                            type="password"
                            placeholder="Password"
                            value={data.password}
                            onChange={(e) => setData({ ...data, password: e.target.value })}
                            className="w-full p-3 border rounded-lg focus:ring-2 focus:ring-blue-500"
                        />
                        <button onClick={handleAuthAction} className="w-full p-3 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors">
                            {isRegistering ? 'Register' : 'Login'}
                        </button>
                        <button onClick={() => { setIsRegistering(!isRegistering); setError(''); }} className="w-full p-3 bg-gray-300 text-black rounded-lg hover:bg-gray-400 transition-colors">
                            {isRegistering ? 'Switch to Login' : 'Switch to Register'}
                        </button>
                    </div>
                </div>
            </div>
        );
    };

    // =========== MAIN APPLICATION COMPONENT ===========
    const App = () => {
        const [currentUser, setCurrentUser] = useState(null);
        const [loading, setLoading] = useState(true);

        useEffect(() => {
            const unsubscribe = auth.onAuthStateChanged(async (user) => {
                if (user) {
                    const userProfileSnapshot = await db.ref(`users/${user.uid}/profile`).once('value');
                    const userProfile = userProfileSnapshot.val();
                    // Set the actual user object and then augment it with profile data
                    user.username = (userProfile?.username || user.email.split('@')[0]).toLowerCase();
                    user.firstName = userProfile?.firstName || '';
                    user.lastName = userProfile?.lastName || '';
                    user.dateOfBirth = userProfile?.dateOfBirth || '';
                    user.shareWorkouts = userProfile?.shareWorkouts ?? true; // Added shareWorkouts, default to true
                    setCurrentUser(user);
                } else {
                    setCurrentUser(null);
                }
                setLoading(false);
            });

            // Register sync event for offline data when online
            if ('serviceWorker' in navigator && 'SyncManager' in window) {
              window.addEventListener('online', async () => {
                console.log('App is online, attempting to sync offline workouts...');
                try {
                  const registration = await navigator.serviceWorker.ready;
                  await registration.sync.register('sync-offline-workouts');
                  console.log('Sync event registered.');
                } catch (error) {
                  console.error('Failed to register sync event:', error);
                }
              });
            }

            return () => unsubscribe();
          }, []);

        if (loading) {
            return <div className="flex justify-center items-center h-screen text-xl">Loading...</div>;
        }

        if (!currentUser) {
            return <AuthPage />;
        }

        return <WorkoutTracker currentUser={currentUser} />;
    };

    const WorkoutTracker = ({ currentUser }) => {
      const [workouts, setWorkouts] = useState([]);
      const [currentUserWorkouts, setCurrentUserWorkouts] = useState([]); // New state for current user's workouts
      const [friendWorkouts, setFriendWorkouts] = useState([]);
      const [chartWorkouts, setChartWorkouts] = useState([]); // New state for chart-specific workouts
      const [allFriendsWorkouts, setAllFriendsWorkouts] = useState([]); // New state for all friends' workouts combined
      const [friends, setFriends] = useState([]);
      const [newWorkoutType, setNewWorkoutType] = useState('');
      const [newFriend, setNewFriend] = useState('');
      const [selectedFriend, setSelectedFriend] = useState(null);
      const [workoutError, setWorkoutError] = useState('');
      const [settingsError, setSettingsError] = useState('');
      const [currentTab, setCurrentTab] = useState('workouts');
      const [newPassword, setNewPassword] = useState('');
      const [currentPassword, setCurrentPassword] = useState('');
      const [firstName, setFirstName] = useState('');
      const [lastName, setLastName] = useState('');
      const [dateOfBirth, setDateOfBirth] = useState('');
      const [shareWorkouts, setShareWorkouts] = useState(currentUser.shareWorkouts); // New state for workout sharing
      const [showNewPassword, setShowNewPassword] = useState(false);
      const [friendRequests, setFriendRequests] = useState([]);
      const [selectedDate, setSelectedDate] = useState(null);
      const [editWorkout, setEditWorkout] = useState(null);
      const [currentMonth, setCurrentMonth] = useState(new Date().getMonth());
      const [currentYear, setCurrentYear] = useState(new Date().getFullYear());
      const [selectedChartDate, setSelectedChartDate] = useState(new Date()); // New state for chart's selected date
      const [showAddPopup, setShowAddPopup] = useState(false);
      const [showDeleteWorkoutPopup, setShowDeleteWorkoutPopup] = useState(null);
      const [showDeleteFriendPopup, setShowDeleteFriendPopup] = useState(null);
      const [suggestions, setSuggestions] = useState([]);
      const [isDropdownOpen, setIsDropdownOpen] = useState(false);
      const [showPassword, setShowPassword] = useState(false); // For current password visibility
      const [showLogoutPopup, setShowLogoutPopup] = useState(false); // New state for logout confirmation popup
      const [exerciseDescription, setExerciseDescription] = useState(''); // New state for exercise description
      const [exerciseImage, setExerciseImage] = useState(''); // New state for exercise image URL
      const [isEditingExercise, setIsEditingExercise] = useState(false); // New state for editing exercise
      const [selectedExercise, setSelectedExercise] = useState(''); // Changed default to empty string
      const [selectedUserForWorkouts, setSelectedUserForWorkouts] = useState(currentUser.uid);
      const [selectedUserForTable, setSelectedUserForTable] = useState(currentUser.uid); // New state for table view user
      const [compareMode, setCompareMode] = useState(false); // New state for compare mode
      const chartRef = useRef(null);
      const chartInstanceRef = useRef(null);

      useEffect(() => {
        if (currentUser) {
          const userProfileRef = db.ref(`users/${currentUser.uid}/profile`);
          userProfileRef.on('value', (snapshot) => {
            const profileData = snapshot.val();
            if (profileData) {
              setFirstName(profileData.firstName || '');
              setLastName(profileData.lastName || '');
              setDateOfBirth(profileData.dateOfBirth || '');
              setShareWorkouts(profileData.shareWorkouts ?? true); // Update shareWorkouts state
            }
          });

          // Load current user's workouts
          const currentUserWorkoutsRef = db.ref(`users/${currentUser.uid}/workouts`);
          currentUserWorkoutsRef.on('value', (snapshot) => {
            const workoutsData = snapshot.val();
            const loadedWorkouts = workoutsData ? Object.keys(workoutsData).map(key => ({ id: key, ...workoutsData[key] })) : [];
            setCurrentUserWorkouts(loadedWorkouts);
          });

          // Load workouts for the selected user (either current user or friend) for the table view
          const workoutsToLoadUidForTableView = selectedUserForTable; // Changed to selectedUserForTable
          const workoutsRefForTableView = db.ref(`users/${workoutsToLoadUidForTableView}/workouts`);
          workoutsRefForTableView.on('value', (snapshot) => {
            const workoutsData = snapshot.val();
            const loadedWorkouts = workoutsData ? Object.keys(workoutsData).map(key => ({ id: key, ...workoutsData[key] })) : [];
            setWorkouts(loadedWorkouts); // This is used for the table display
          });

          // Load workouts for the selected user for charts
          const workoutsToLoadUidForCharts = selectedUserForWorkouts;
          const workoutsRefForCharts = db.ref(`users/${workoutsToLoadUidForCharts}/workouts`);
          workoutsRefForCharts.on('value', (snapshot) => {
            const workoutsData = snapshot.val();
            const loadedWorkouts = workoutsData ? Object.keys(workoutsData).map(key => ({ id: key, ...workoutsData[key] })) : [];
            setChartWorkouts(loadedWorkouts);
          });

          // Load all visible friends' workouts for calendar display
          const allFriendsWorkoutsRef = db.ref(`users/${currentUser.uid}/friends`);
          allFriendsWorkoutsRef.on('value', async (snapshot) => {
            const friendsData = snapshot.val();
            const loadedAllFriendsWorkouts = [];
            if (friendsData) {
              for (const friendUid in friendsData) {
                const friendInfo = friendsData[friendUid];
                const friendProfileSnapshot = await db.ref(`users/${friendUid}/profile`).once('value');
                const friendProfile = friendProfileSnapshot.val();
                if (friendProfile?.shareWorkouts) { // Check friend's shareWorkouts setting
                  const friendWorkoutsSnapshot = await db.ref(`users/${friendUid}/workouts`).once('value');
                  const friendWorkoutsData = friendWorkoutsSnapshot.val();
                  if (friendWorkoutsData) {
                    Object.keys(friendWorkoutsData).forEach(key => {
                      loadedAllFriendsWorkouts.push({ id: key, ...friendWorkoutsData[key] });
                    });
                  }
                }
              }
            }
            setAllFriendsWorkouts(loadedAllFriendsWorkouts);
          });

          const userFriendsRef = db.ref(`users/${currentUser.uid}/friends`);
          userFriendsRef.on('value', async (snapshot) => {
            const friendsData = snapshot.val();
            const loadedFriends = [];
            if (friendsData) {
              for (const friendUid in friendsData) {
                const friendInfo = friendsData[friendUid];
                const friendProfileSnapshot = await db.ref(`users/${friendUid}/profile`).once('value');
                const friendProfile = friendProfileSnapshot.val();
                loadedFriends.push({
                  name: friendInfo.username || friendProfile?.username || 'Unknown',
                  uid: friendUid,
                  visible: friendInfo.visible,
                  workouts: [],
                  firstName: friendProfile?.firstName || '',
                  lastName: friendProfile?.lastName || ''
                });
              }
            }
            setFriends(loadedFriends);
          });

          const friendRequestsRef = db.ref(`users/${currentUser.uid}/friendRequests`);
          friendRequestsRef.on('value', (snapshot) => {
            const requestsData = snapshot.val();
            const loadedRequests = [];
            if (requestsData) {
              for (const senderUid in requestsData) {
                loadedRequests.push({
                  uid: senderUid,
                  username: requestsData[senderUid].username || 'Unknown',
                  firstName: requestsData[senderUid].firstName || '',
                  lastName: requestsData[senderUid].lastName || ''
                });
              }
            }
            setFriendRequests(loadedRequests);
          });

          if (selectedFriend) {
            const friendWorkoutsRef = db.ref(`users/${selectedFriend.uid}/workouts`);
            friendWorkoutsRef.on('value', (snapshot) => {
              const friendWorkoutsData = snapshot.val();
              const loadedFriendWorkouts = friendWorkoutsData ? Object.keys(friendWorkoutsData).map(key => ({ id: key, ...friendWorkoutsData[key] })) : [];
              setFriends(prevFriends => prevFriends.map(f =>
                f.uid === selectedFriend.uid ? { ...f, workouts: loadedFriendWorkouts } : f
              ));
            });
          }

          return () => {
            userProfileRef.off();
            currentUserWorkoutsRef.off(); // Corrected from workoutsRef
            workoutsRefForTableView.off(); // Added this line for the table view workouts
            workoutsRefForCharts.off(); // Add this cleanup for chart workouts
            userFriendsRef.off();
            friendRequestsRef.off();
            if (selectedFriend) {
              db.ref(`users/${selectedFriend.uid}/workouts`).off();
            }
          };
        }
      }, [currentUser, selectedFriend, selectedUserForWorkouts, currentUserWorkouts, chartWorkouts]); // Added currentUserWorkouts and chartWorkouts to dependency array

      useEffect(() => {
        setSettingsError('');
      }, [currentTab]);

      useEffect(() => {
        if (showAddPopup && selectedDate) {
          const uniqueTypes = getUniqueWorkoutTypes(currentUserWorkouts); // Pass currentUserWorkouts
          setSuggestions(uniqueTypes);
        }
      }, [showAddPopup, selectedDate, currentUserWorkouts]); // Add currentUserWorkouts to dependency array

      useEffect(() => {
        if (showAddPopup && selectedDate) {
          const allUniqueTypes = getUniqueWorkoutTypes(currentUserWorkouts);
          if (newWorkoutType) {
            const filtered = allUniqueTypes.filter(type =>
              type.toLowerCase().includes(newWorkoutType.toLowerCase())
            );
            setSuggestions(filtered);
          } else {
            setSuggestions(allUniqueTypes); // Show all suggestions when input is empty
          }
        }
      }, [newWorkoutType, showAddPopup, selectedDate, currentUserWorkouts]); // Added currentUserWorkouts to dependency array

      useEffect(() => {
        setSelectedExercise(''); // Reset selected exercise when user changes
        if (selectedUserForWorkouts === currentUser.uid) {
          setCompareMode(false); // Turn off compare mode if "Me" is selected
        }
      }, [selectedUserForWorkouts]);

      useEffect(() => {
        if (currentTab === 'charts' && chartRef.current) {
          if (chartInstanceRef.current) {
            chartInstanceRef.current.destroy();
          }

          const filterWorkouts = (userWorkouts, exerciseType) => {
            return exerciseType
              ? userWorkouts.filter(w => w.type === exerciseType)
              : userWorkouts;
          };

          const processChartData = (userWorkouts, exerciseType, chartDate) => {
            const startOfWeek = getStartOfWeek(chartDate);
            const endOfWeek = getEndOfWeek(chartDate);
            const daysOfWeek = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
            const dataByDay = {};

            // Initialize data for each day of the week
            for (let i = 0; i < 7; i++) {
              const currentDay = new Date(startOfWeek);
              currentDay.setDate(startOfWeek.getDate() + i);
              // Normalize currentDay to local midnight for consistent key generation
              currentDay.setHours(0, 0, 0, 0);
              dataByDay[currentDay.toLocaleDateString('en-CA', { year: 'numeric', month: '2-digit', day: '2-digit' })] = { sets: 0, reps: 0, weight: 0, count: 0 };
            }

            const filtered = filterWorkouts(userWorkouts, exerciseType);

            filtered.forEach(w => {
              const workoutDate = new Date(w.date); // This is already a local date if w.date is YYYY-MM-DD
              workoutDate.setHours(0, 0, 0, 0); // Normalize to start of the day in local time for comparison
              
              // Check if workoutDate is within the selected week (using local time for comparison)
              if (workoutDate >= startOfWeek && workoutDate <= endOfWeek) {
                const dayKey = workoutDate.toLocaleDateString('en-CA', { year: 'numeric', month: '2-digit', day: '2-digit' }); // Use YYYY-MM-DD based on local time
                if (dataByDay[dayKey]) {
                  dataByDay[dayKey].sets += parseInt(w.sets || '0', 10);
                  dataByDay[dayKey].reps += parseInt(w.reps || '0', 10);
                  dataByDay[dayKey].weight += parseInt(w.weight || '0', 10);
                  dataByDay[dayKey].count++;
                }
              }
            });

            const labels = [];
            const setsData = [];
            const repsData = [];
            const weightData = [];

            for (let i = 0; i < 7; i++) {
              const currentDay = new Date(startOfWeek);
              currentDay.setDate(startOfWeek.getDate() + i);
              currentDay.setHours(0, 0, 0, 0); // Normalize to start of the day in local time
              const dayKey = currentDay.toISOString().slice(0, 10); // Use YYYY-MM-DD based on local time
              labels.push(daysOfWeek[i] + ' ' + currentDay.getDate()); // Use getDate for label
              setsData.push(dataByDay[dayKey]?.sets || 0); // Use optional chaining and default to 0
              repsData.push(dataByDay[dayKey]?.reps || 0);
              weightData.push(dataByDay[dayKey]?.weight || 0);
            }

            return { labels, setsData, repsData, weightData };
          };

          let { labels, setsData, repsData, weightData } = processChartData(chartWorkouts, selectedExercise, selectedChartDate);
          let currentUserChartData = { labels: [], setsData: [], repsData: [], weightData: [] };

          if (compareMode && selectedUserForWorkouts !== currentUser.uid) {
            currentUserChartData = processChartData(currentUserWorkouts, selectedExercise, selectedChartDate);
          }

          const datasets = [];

          if (setsData.length > 0) {
            datasets.push({
              label: 'Sets',
              data: setsData,
              backgroundColor: 'rgba(255, 99, 132, 0.5)', // Red
              borderColor: 'rgba(255, 99, 132, 1)',
              borderWidth: 1,
              yAxisID: 'y'
            });
          }
          if (repsData.length > 0) {
            datasets.push({
              label: 'Reps',
              data: repsData,
              backgroundColor: 'rgba(54, 162, 235, 0.5)', // Blue
              borderColor: 'rgba(54, 162, 235, 1)',
              borderWidth: 1,
              yAxisID: 'y'
            });
          }
          if (weightData.length > 0) {
            datasets.push({
              label: 'Weight',
              data: weightData,
              backgroundColor: 'rgba(75, 192, 192, 0.5)', // Green
              borderColor: 'rgba(75, 192, 192, 1)',
              borderWidth: 1,
              yAxisID: 'y'
            });
          }

          if (compareMode && selectedUserForWorkouts !== currentUser.uid) {
            if (currentUserChartData.setsData.length > 0) {
              datasets.push({
                label: 'My Sets',
                data: currentUserChartData.setsData,
                backgroundColor: 'rgba(255, 99, 132, 0.2)', // Lighter Red
                borderColor: 'rgba(255, 99, 132, 0.8)',
                borderWidth: 1,
                yAxisID: 'y'
              });
            }
            if (currentUserChartData.repsData.length > 0) {
              datasets.push({
                label: 'My Reps',
                data: currentUserChartData.repsData,
                backgroundColor: 'rgba(54, 162, 235, 0.2)', // Lighter Blue
                borderColor: 'rgba(54, 162, 235, 0.8)',
                borderWidth: 1,
                yAxisID: 'y'
              });
            }
            if (currentUserChartData.weightData.length > 0) {
              datasets.push({
                label: 'My Weight',
                data: currentUserChartData.weightData,
                backgroundColor: 'rgba(75, 192, 192, 0.2)', // Lighter Green
                borderColor: 'rgba(75, 192, 192, 0.8)',
                borderWidth: 1,
                yAxisID: 'y'
              });
            }
          }
          
          chartInstanceRef.current = new Chart(chartRef.current, {
            type: 'bar',
            data: {
              labels,
              datasets
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              scales: {
                y: { beginAtZero: true, title: { display: true, text: 'Value' } },
                x: { title: { display: true, text: 'Week Start Date' } }
              }
            }
          });

        }
        return () => {
          if (chartInstanceRef.current) {
            chartInstanceRef.current.destroy();
            chartInstanceRef.current = null;
          }
        };
      }, [currentTab, selectedUserForWorkouts, selectedExercise, compareMode, selectedChartDate]);

      const handleLogout = async () => {
        try {
          await auth.signOut();
          setWorkouts([]);
          setFriends([]);
          setSelectedFriend(null);
          setCurrentTab('workouts');
          setSelectedDate(null);
        } catch (error) {
          console.error("Error signing out:", error);
        }
      };

      const handleChangePassword = async () => {
        if (currentPassword && newPassword) {
          try {
            const credential = firebase.auth.EmailAuthProvider.credential(currentUser.email, currentPassword);
            await currentUser.reauthenticateWithCredential(credential);
            await currentUser.updatePassword(newPassword);
            setCurrentPassword('');
            setNewPassword('');
            setSettingsError('Password updated successfully');
          } catch (error) {
            setSettingsError(error.message);
          }
        } else {
          setSettingsError('Please fill in all fields');
        }
      };

      const handleUpdateProfile = async () => {
        try {
          await db.ref(`users/${currentUser.uid}/profile`).update({
            firstName: firstName,
            lastName: lastName,
            dateOfBirth: dateOfBirth,
            shareWorkouts: shareWorkouts // Update shareWorkouts in profile
          });
          setSettingsError('Profile updated successfully');
        } catch (error) {
          setSettingsError(error.message);
        }
      };

      const addWorkout = async () => {
        if (newWorkoutType && selectedDate) {
          const existingWorkout = getWorkoutsForDate(selectedDate, workouts).find(w => w.type === newWorkoutType);
          if (existingWorkout) {
            setWorkoutError('This exercise already exists for the selected date!');
            return;
          }
          const newWorkoutRef = db.ref(`users/${currentUser.uid}/workouts`).push();
          const newWorkoutData = { type: newWorkoutType, user: currentUser.username, date: selectedDate, sets: '0', reps: '0', weight: '0' };
          try {
            await newWorkoutRef.set(newWorkoutData);
            setNewWorkoutType('');
            setWorkoutError('');
            setShowAddPopup(false); // Close modal on success
            setSuggestions([]);
            setIsDropdownOpen(false);
          } catch (error) {
            console.error("Error adding workout:", error);
            if (!navigator.onLine) {
              const localWorkouts = JSON.parse(localStorage.getItem('offlineWorkouts')) || [];
              localWorkouts.push({ id: newWorkoutRef.key, userUid: currentUser.uid, action: 'add', data: newWorkoutData, status: 'pending' });
              localStorage.setItem('offlineWorkouts', JSON.stringify(localWorkouts));
              setWorkoutError('Failed to add workout. Data saved locally and will sync when online.');
            } else {
              setWorkoutError('Failed to add workout. Please try again.');
            }
            setShowAddPopup(false); // Close modal even on error
          }
        } else {
          setWorkoutError('Please enter a workout type');
        }
      };

      const updateWorkout = async () => {
        if (editWorkout.type) {
          try {
            await db.ref(`users/${currentUser.uid}/workouts/${editWorkout.id}`).set({
              type: editWorkout.type,
              user: editWorkout.user,
              date: editWorkout.date,
              sets: editWorkout.sets,
              reps: editWorkout.reps,
              weight: editWorkout.weight
            });
            setEditWorkout(null);
            setWorkoutError('');
            setShowAddPopup(false); // Close modal on success
            setSuggestions([]);
            setIsDropdownOpen(false);
            setIsEditingExercise(false); // Close editing field
            setSelectedExercise(null); // Deselect exercise
          } catch (error) {
            console.error("Error updating workout:", error);
            if (!navigator.onLine) {
              const localWorkouts = JSON.parse(localStorage.getItem('offlineWorkouts')) || [];
              const existingIndex = localWorkouts.findIndex(w => w.id === editWorkout.id);
              if (existingIndex > -1) {
                localWorkouts[existingIndex] = { id: editWorkout.id, userUid: currentUser.uid, action: 'update', data: updatedWorkoutData, status: 'pending' };
              } else {
                localWorkouts.push({ id: editWorkout.id, userUid: currentUser.uid, action: 'update', data: updatedWorkoutData, status: 'pending' });
              }
              localStorage.setItem('offlineWorkouts', JSON.stringify(localWorkouts));
              setWorkoutError('Failed to update workout. Data saved locally and will sync when online.');
            } else {
              setWorkoutError('Failed to update workout. Please try again.');
            }
            setShowAddPopup(false); // Close modal even on error
          }
        } else {
          setWorkoutError('Please enter a workout type');
        }
      };

      const confirmDeleteWorkout = async (id) => {
        try {
          await db.ref(`users/${currentUser.uid}/workouts/${id}`).remove();
          setShowDeleteWorkoutPopup(null); // Close modal on success
        } catch (error) {
          console.error("Error deleting workout:", error);
          if (!navigator.onLine) {
            const localWorkouts = JSON.parse(localStorage.getItem('offlineWorkouts')) || [];
            const updatedLocalWorkouts = localWorkouts.filter(w => w.id !== id);
            localStorage.setItem('offlineWorkouts', JSON.stringify(updatedLocalWorkouts));
            setWorkoutError('Failed to delete workout. Data saved locally and will sync when online.');
          } else {
            setWorkoutError('Failed to delete workout. Please try again.');
          }
          setShowDeleteWorkoutPopup(null); // Close modal even on error
        }
      };

      const updateWorkoutMetrics = async (id, metrics) => {
        await db.ref(`users/${currentUser.uid}/workouts/${id}`).update(metrics);
      };

      const sendFriendRequest = async () => {
        if (newFriend && newFriend.trim() !== '') {
          const friendUsernameLower = newFriend.toLowerCase().trim();
          if (friendUsernameLower === currentUser.username.toLowerCase()) {
            setSettingsError('You cannot send a friend request to yourself.');
            return;
          }

          const friendUidSnapshot = await db.ref(`usernames/${friendUsernameLower}`).once('value');
          if (!friendUidSnapshot.exists()) {
            setSettingsError('User not found.');
            return;
          }
          const friendUid = friendUidSnapshot.val().uid;

          // Check if already friends
          const existingFriendship = await db.ref(`users/${currentUser.uid}/friends/${friendUsernameLower}`).once('value');
          if (existingFriendship.exists()) {
            setSettingsError('You are already friends with this user.');
            return;
          }


          // Check if request already received
          const existingRequestReceived = await db.ref(`users/${currentUser.uid}/friendRequests/${friendUid}`).once('value');
          if (existingRequestReceived.exists()) {
            setSettingsError('This user has already sent you a friend request. Please accept it in the requests section.');
            return;
          }

          // Send request
          await db.ref(`users/${friendUid}/friendRequests/${currentUser.uid}`).set({
            username: currentUser.username,
            firstName: currentUser.firstName,
            lastName: currentUser.lastName,
            email: currentUser.email // Include email for reauthentication if needed
          });
          setNewFriend('');
          setSettingsError('Friend request sent!');
        } else {
          setSettingsError('Please enter a friend\'s username.');
        }
      };

      const acceptFriendRequest = async (requesterUid, requesterUsername) => {
        try {
          const updates = {};
          // Add to current user's friends, using requesterUid as key
          updates[`users/${currentUser.uid}/friends/${requesterUid}`] = { username: requesterUsername, visible: true };
          // Add current user to requester's friends, using currentUser.uid as key
          updates[`users/${requesterUid}/friends/${currentUser.uid}`] = { username: currentUser.username, visible: true, uid: currentUser.uid };
          // Remove request
          updates[`users/${currentUser.uid}/friendRequests/${requesterUid}`] = null; // Use null to remove

          await db.ref().update(updates); // Perform atomic multi-path update

          setSettingsError('Friend request accepted!');
          // Update friend requests state to reflect the change immediately
          setFriendRequests(prevRequests => prevRequests.filter(req => req.uid !== requesterUid));
        } catch (error) {
          setSettingsError(error.message);
        }
      };

      const declineFriendRequest = async (requesterUid) => {
        try {
          await db.ref(`users/${currentUser.uid}/friendRequests/${requesterUid}`).remove();
          setSettingsError('Friend request declined.');
          // Update friend requests state to reflect the change immediately
          setFriendRequests(prevRequests => prevRequests.filter(req => req.uid !== requesterUid));
        } catch (error) {
          setSettingsError(error.message);
        }
      };

      const removeFriend = async (friendUid, friendUsername) => {
        try {
          // Remove from current user's friends
          await db.ref(`users/${currentUser.uid}/friends/${friendUid}`).remove();
          // Remove current user from friend's friends
          await db.ref(`users/${friendUid}/friends/${currentUser.uid}`).remove();
          setSettingsError('Friend removed successfully.');

          if (selectedFriend && selectedFriend.uid === friendUid) {
            setSelectedFriend(null);
          }
          setShowDeleteFriendPopup(null);
        } catch (error) {
          setSettingsError(error.message);
        }
      };

      const toggleFriendVisibility = async (friendUid) => {
        const friendRef = db.ref(`users/${currentUser.uid}/friends/${friendUid}`);
        const snapshot = await friendRef.once('value');
        const currentVisibility = snapshot.val()?.visible;
        await friendRef.update({ visible: !currentVisibility });
      };

      const getStartOfWeek = (date) => {
        const d = new Date(date);
        d.setHours(0, 0, 0, 0); // Normalize to start of the day in local time
        const day = d.getDay(); // 0 for Sunday, 1 for Monday, ..., 6 for Saturday
        const diff = d.getDate() - day + (day === 0 ? -6 : 1); // Adjust to Monday of the current week
        d.setDate(diff);
        return d;
      };

      const getEndOfWeek = (date) => {
        const startOfWeek = getStartOfWeek(date);
        const endOfWeek = new Date(startOfWeek);
        endOfWeek.setDate(startOfWeek.getDate() + 6);
        endOfWeek.setHours(23, 59, 59, 999); // Set to end of the day in local time
        return endOfWeek;
      };

      const changeWeek = (delta) => {
        setSelectedChartDate(prevDate => {
          const newDate = new Date(prevDate);
          newDate.setDate(prevDate.getDate() + delta * 7);
          return newDate;
        });
      };

      const getDaysInMonth = () => {
        const days = new Date(currentYear, currentMonth + 1, 0).getDate();
        const firstDay = new Date(currentYear, currentMonth, 1).getDay();
        const offset = firstDay === 0 ? 6 : firstDay - 1;
        const daysArray = Array.from({ length: days }, (_, i) => i + 1);
        return { daysArray, offset };
      };

      const getWorkoutsForDate = (date, userWorkouts) => {
        // Normalize the input date to YYYY-MM-DD for consistent comparison
        const normalizedDate = new Date(date).toISOString().slice(0, 10);
        return userWorkouts.filter(w => {
          const workoutDate = new Date(w.date);
          return workoutDate.toISOString().slice(0, 10) === normalizedDate;
        });
      };

      const getWorkoutDays = (userWorkouts) => {
        return new Set(userWorkouts.map(w => new Date(w.date).toISOString().slice(0, 10)));
      };

      const getUniqueWorkoutTypes = (workoutList) => {
        return [...new Set(workoutList.map(w => w.type))];
      };

      const changeMonth = (delta) => {
        let newMonth = currentMonth + delta;
        let newYear = currentYear;
        if (newMonth < 0) { newMonth = 11; newYear -= 1; }
        else if (newMonth > 11) { newMonth = 0; newYear += 1; }
        setCurrentMonth(newMonth);
        setCurrentYear(newYear);
      };

      const isToday = (day) => {
        const today = new Date();
        return day === today.getDate() && currentMonth === today.getMonth() && currentYear === today.getFullYear();
      };

      const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];

      return (
        <div className="container mx-auto p-4 max-w-4xl">
          <div className="flex justify-between items-center mb-6">
            <h1 className="text-3xl font-bold">Gym Bros</h1>
          </div>

          <div className="flex space-x-4 mb-6">
            <button onClick={() => setCurrentTab('workouts')} className={`p-2 rounded ${currentTab === 'workouts' ? 'bg-blue-500 text-white' : 'bg-gray-200'}`}>Workouts</button>
            <button onClick={() => setCurrentTab('charts')} className={`p-2 rounded ${currentTab === 'charts' ? 'bg-blue-500 text-white' : 'bg-gray-200'}`}>Charts</button>
            <button onClick={() => setCurrentTab('settings')} className={`p-2 rounded ${currentTab === 'settings' ? 'bg-blue-500 text-white' : 'bg-gray-200'}`}>Settings</button>
          </div>

          {currentTab === 'workouts' && (
            <div>
              {selectedDate ? (
                <div>
                  <div className="flex justify-between items-center mb-4">
                    <button onClick={() => setSelectedDate(null)} className="p-2 bg-gray-300 text-black rounded hover:bg-gray-400">Back to Calendar</button>
                    {selectedUserForTable === currentUser.uid && (
                      <button onClick={() => setShowAddPopup(true)} className="p-2 bg-blue-500 text-white rounded hover:bg-blue-600">Add Workout</button>
                    )}
                  </div>
                  <h2 className="text-xl font-semibold mb-4">Workouts for {selectedDate}</h2>
                  {workoutError && <p className="text-red-500 mb-4">{workoutError}</p>}
                  <div className="mb-4">
                    <label htmlFor="workout-user-select" className="block text-sm font-medium text-gray-700 mb-1">View Workouts For:</label>
                    <select
                      id="workout-user-select"
                      value={selectedUserForTable}
                      onChange={(e) => setSelectedUserForTable(e.target.value)}
                      className="w-full p-2 border rounded-lg focus:ring-2 focus:ring-blue-500"
                    >
                      <option value={currentUser.uid}>Me ({currentUser.username})</option>
                      {friends.filter(f => f.visible).map(friend => (
                        <option key={friend.uid} value={friend.uid}>
                          {friend.firstName} {friend.lastName} ({friend.name})
                        </option>
                      ))}
                    </select>
                  </div>
                  <div className="overflow-x-auto">
                    <table className="w-full bg-white rounded-lg shadow table-fixed">
                      <thead>
                        <tr className="bg-gray-200">
                          <th className="w-48 p-2 text-left">Exercises</th>
                          <th className="flex-1 p-2 text-center">
                            {selectedUserForTable === currentUser.uid ? currentUser.username : friends.find(f => f.uid === selectedUserForTable)?.name || 'Friend'}
                            <div className="flex justify-center space-x-2 mt-1 text-sm text-gray-600">
                              <span className="w-1/3 text-center">Sets</span>
                              <span className="w-1/3 text-center">Reps</span>
                              <span className="w-1/3 text-center">Weight</span>
                            </div>
                          </th>
                        </tr>
                      </thead>
                      <tbody>
                        {getWorkoutsForDate(selectedDate, workouts).map(workout => (
                          <tr key={workout.id}>
                            <td className="w-48 p-2 border-t">
                              <div className="flex justify-between items-center">
                                <span className="flex-grow">{workout.type}</span>
                                {selectedUserForTable === currentUser.uid && (
                                  <div className="flex-shrink-0 flex space-x-2">
                                    <button onClick={() => { setEditWorkout(workout); setNewWorkoutType(workout.type); setShowAddPopup(true); }} className="p-1 text-yellow-500 hover:text-yellow-600">
                                      <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.536L16.732 3.732z"></path></svg>
                                    </button>
                                    <button onClick={() => setShowDeleteWorkoutPopup(workout.id)} className="p-1 text-red-500 hover:text-red-600">
                                      <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                                    </button>
                                  </div>
                                )}
                              </div>
                            </td>
                            <td className="flex-1 p-2 border-t text-center">
                              <div className="flex justify-center space-x-2">
                                <input type="number" placeholder="Sets" value={workout.sets} onFocus={(e) => { if (e.target.value === '0') e.target.value = ''; }} onBlur={(e) => { if (e.target.value === '') e.target.value = '0'; }} onChange={(e) => updateWorkoutMetrics(workout.id, { sets: e.target.value })} className="w-1/3 p-1 border rounded text-center" disabled={selectedUserForTable !== currentUser.uid} />
                                <input type="number" placeholder="Reps" value={workout.reps} onFocus={(e) => { if (e.target.value === '0') e.target.value = ''; }} onBlur={(e) => { if (e.target.value === '') e.target.value = '0'; }} onChange={(e) => updateWorkoutMetrics(workout.id, { reps: e.target.value })} className="w-1/3 p-1 border rounded text-center" disabled={selectedUserForTable !== currentUser.uid} />
                                <input type="number" placeholder="Weight" value={workout.weight} onFocus={(e) => { if (e.target.value === '0') e.target.value = ''; }} onBlur={(e) => { if (e.target.value === '') e.target.value = '0'; }} onChange={(e) => updateWorkoutMetrics(workout.id, { weight: e.target.value })} className="w-1/3 p-1 border rounded text-center" disabled={selectedUserForTable !== currentUser.uid} />
                              </div>
                            </td>
                          </tr>
                        ))}
                      </tbody>
                    </table>
                  </div>

                  {showAddPopup && (
                    <div className="fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 backdrop-blur-sm">
                      <div className="bg-white p-6 rounded-lg shadow-lg max-w-md w-full">
                        <h3 className="text-lg font-semibold mb-4">{editWorkout ? 'Edit Workout' : 'Add Workout'}</h3>
                        <div className="space-y-4">
                          <div className="relative">
                            <input
                              type="text"
                              placeholder="Workout Type (e.g., Running)"
                              value={newWorkoutType}
                              onChange={(e) => { setNewWorkoutType(e.target.value); setIsDropdownOpen(true); }}
                              onFocus={() => setIsDropdownOpen(true)}
                              
                              className="w-full p-2 border rounded"
                            />
                            {isDropdownOpen && suggestions.length > 0 && (
                              <div className="absolute z-10 w-full bg-white border rounded shadow-lg mt-1 max-h-40 overflow-y-auto">
                                {suggestions.map((type, index) => (
                                  <div
                                    key={index}
                                    onClick={() => { setNewWorkoutType(type); setIsDropdownOpen(false); }}
                                    className="p-2 hover:bg-gray-100 cursor-pointer"
                                  >
                                    {type}
                                  </div>
                                ))}
                              </div>
                            )}
                          </div>
                          <div className="flex space-x-2">
                            <button onClick={editWorkout ? updateWorkout : addWorkout} disabled={!!getWorkoutsForDate(selectedDate, workouts).find(w => w.type === newWorkoutType) && !editWorkout} className="flex-1 p-2 bg-blue-500 text-white rounded hover:bg-blue-600 disabled:bg-gray-400 disabled:cursor-not-allowed">
                              {editWorkout ? 'Update' : 'Add'}
                            </button>
                            <button onClick={() => { setShowAddPopup(false); setEditWorkout(null); setNewWorkoutType(''); setWorkoutError(''); setSuggestions([]); setIsDropdownOpen(false); }} className="flex-1 p-2 bg-gray-300 text-black rounded hover:bg-gray-400">
                              Cancel
                            </button>
                          </div>
                        </div>
                        {workoutError && <p className="text-red-500 mt-2">{workoutError}</p>}
                      </div>
                    </div>
                  )}

                  {showDeleteWorkoutPopup && (
                    <div className="fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 backdrop-blur-sm">
                      <div className="bg-white p-6 rounded-lg shadow-lg max-w-md w-full">
                        <h3 className="text-lg font-semibold mb-4">Confirm Deletion</h3>
                        <p className="mb-4">Are you sure you want to delete this workout? This action is permanent.</p>
                        <div className="flex space-x-2">
                          <button onClick={() => confirmDeleteWorkout(showDeleteWorkoutPopup)} className="flex-1 p-2 bg-red-500 text-white rounded hover:bg-red-600">Confirm</button>
                          <button onClick={() => setShowDeleteWorkoutPopup(null)} className="flex-1 p-2 bg-gray-300 text-black rounded hover:bg-gray-400">Cancel</button>
                        </div>
                      </div>
                    </div>
                  )}
                </div>
              ) : (
                <div className="p-4 bg-white rounded-lg shadow">
                  <div className="flex justify-between items-center mb-4">
                    <button onClick={() => changeMonth(-1)} className="p-2 bg-gray-300 rounded hover:bg-gray-400">Previous</button>
                    <h2 className="text-xl font-semibold">{monthNames[currentMonth]} {currentYear}</h2>
                    <button onClick={() => changeMonth(1)} className="p-2 bg-gray-300 rounded hover:bg-gray-400">Next</button>
                  </div>
                  <div className="grid grid-cols-7 gap-2">
                    {['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'].map(day => <div key={day} className="text-center font-medium">{day}</div>)}
                    {Array(getDaysInMonth().offset).fill(null).map((_, i) => <div key={`empty-${i}`} className="p-2"></div>)}
                    {getDaysInMonth().daysArray.map(day => {
                      // Construct date string in YYYY-MM-DD format for consistency
                      const date = `${currentYear}-${String(currentMonth + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
                      const currentUserHasWorkouts = getWorkoutDays(currentUserWorkouts).has(date);
                      const anyFriendHasWorkouts = allFriendsWorkouts.some(w => new Date(w.date).toISOString().slice(0, 10) === date);
                      const today = isToday(day);

                      let bgColorClass = 'bg-gray-50';
                      let content = day;

                      if (currentUserHasWorkouts && anyFriendHasWorkouts) {
                        bgColorClass = 'bg-gradient-to-br from-green-100 to-yellow-100';
                      } else if (currentUserHasWorkouts) {
                        bgColorClass = 'bg-green-100';
                      } else if (anyFriendHasWorkouts) { // Changed to anyFriendHasWorkouts
                        bgColorClass = 'bg-yellow-100';
                      }

                      return (
                        <button key={day} onClick={() => setSelectedDate(date)} className={`p-2 rounded flex items-center justify-center ${bgColorClass} hover:bg-blue-200`}>
                          {content}{today && <span className="ml-1 text-yellow-500">★</span>}
                        </button>
                      );
                    })}
                  </div>
                </div>
              )}
            </div>
          )}

          {currentTab === 'charts' && (
            <div className="p-4 bg-white rounded-lg shadow">
              <h2 className="text-xl font-semibold mb-4">Workout Progress Charts</h2>
              <div className="flex justify-between items-center mb-4">
                <button onClick={() => changeWeek(-1)} className="p-2 bg-gray-300 rounded hover:bg-gray-400">Previous Week</button>
                <h3 className="text-lg font-semibold">
                  {getStartOfWeek(selectedChartDate).toLocaleDateString()} - {getEndOfWeek(selectedChartDate).toLocaleDateString()}
                </h3>
                <button onClick={() => changeWeek(1)} className="p-2 bg-gray-300 rounded hover:bg-gray-400">Next Week</button>
              </div>
              <div className="mb-4">
                <label htmlFor="chart-user-select" className="block text-sm font-medium text-gray-700 mb-1">View Charts For:</label>
                <select
                  id="chart-user-select"
                  value={selectedUserForWorkouts}
                  onChange={(e) => setSelectedUserForWorkouts(e.target.value)}
                  className="w-full p-2 border rounded-lg focus:ring-2 focus:ring-blue-500"
                >
                  <option value={currentUser.uid}>Me ({currentUser.username})</option>
                  {friends.filter(f => f.visible).map(friend => (
                    <option key={friend.uid} value={friend.uid}>
                      {friend.firstName} {friend.lastName} ({friend.name})
                    </option>
                  ))}
                </select>
              </div>

              <div className="mb-4">
                <label htmlFor="exercise-select" className="block text-sm font-medium text-gray-700 mb-1">Select Exercise:</label>
                <select
                  id="exercise-select"
                  value={selectedExercise || ''}
                  onChange={(e) => setSelectedExercise(e.target.value)}
                  className="w-full p-2 border rounded-lg focus:ring-2 focus:ring-blue-500"
                >
                  <option value="">All Exercises</option>
                  {getUniqueWorkoutTypes(chartWorkouts).map(type => (
                    <option key={type} value={type}>{type}</option>
                  ))}
                </select>
              </div>

              {selectedUserForWorkouts !== currentUser.uid && (
                <div className="mb-4">
                  <button onClick={() => setCompareMode(!compareMode)} className={`p-2 rounded ${compareMode ? 'bg-red-500 text-white' : 'bg-blue-500 text-white'} hover:bg-blue-600`}>
                    {compareMode ? 'Stop Comparing' : 'Compare with My Data'}
                  </button>
                </div>
              )}

              <div style={{ position: 'relative', height: '400px', width: '100%', marginBottom: '20px' }}>
                {workouts.length > 0 ? <canvas ref={chartRef} style={{ position: 'absolute', top: 0, left: 0, right: 0, bottom: 0 }}></canvas> : <p className="text-gray-500">No workouts to display yet.</p>}
              </div>
            </div>
          )}

          {currentTab === 'settings' && (
            <div className="p-4 bg-white rounded-lg shadow">
              <h2 className="text-xl font-semibold mb-4">Settings</h2>
              {settingsError && <p className="text-red-500 mb-4">{settingsError}</p>}
              <div className="space-y-6">
                {/* Profile Settings */}
                <div>
                  <h3 className="text-lg font-medium mb-2">Profile Settings</h3>
                  <p className="text-gray-600 mb-4">Username: {currentUser.username}</p>
                  <div className="space-y-4">
                    <input type="text" placeholder="First Name" value={firstName} onChange={(e) => setFirstName(e.target.value)} className="w-full p-2 border rounded" />
                    <input type="text" placeholder="Last Name" value={lastName} onChange={(e) => setLastName(e.target.value)} className="w-full p-2 border rounded" />
                    <input type="date" placeholder="Date of Birth" value={dateOfBirth} onChange={(e) => setDateOfBirth(e.target.value)} className="w-full p-2 border rounded" />
                    <div className="flex items-center">
                      <input
                        type="checkbox"
                        id="shareWorkouts"
                        checked={shareWorkouts}
                        onChange={(e) => setShareWorkouts(e.target.checked)}
                        className="mr-2"
                      />
                      <label htmlFor="shareWorkouts" className="text-gray-700">Share my workouts with friends</label>
                    </div>
                    <button onClick={handleUpdateProfile} className="w-full p-2 bg-blue-500 text-white rounded hover:bg-blue-600">Update Profile</button>
                  </div>
                </div>

                {/* Password Settings */}
                <div>
                  <h3 className="text-lg font-medium mb-2">Password Settings</h3>
                  <div className="space-y-4">
                    <div className="relative">
                      <input type={showPassword ? 'text' : 'password'} placeholder="Current Password" value={currentPassword} onChange={(e) => setCurrentPassword(e.target.value)} className="w-full p-2 border rounded pr-10" />
                      <button onClick={() => setShowPassword(!showPassword)} className="absolute right-2 top-2 p-1 text-gray-500 hover:text-gray-700">
                        {showPassword ? (
                          <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M13.875 18.825A10.05 10.05 0 0112 19c-4.478 0-8.268-2.943-9.543-7a9.97 9.97 0 011.563-3.029m5.858.908a3 3 0 114.243 4.243M9.878 9.878l4.242 4.242M9.88 9.88l-3.29-3.29m7.532 7.532l3.29 3.29M3 3l3.59 3.59m0 0A9.953 9.953 0 0112 5c4.478 0 8.268 2.943 9.543 7a10.025 10.025 0 01-4.132 5.411m0 0L21 21"></path></svg>
                        ) : (
                          <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"></path></svg>
                        )}
                      </button>
                    </div>
                    <div className="relative">
                      <input type={showNewPassword ? 'text' : 'password'} placeholder="New Password" value={newPassword} onChange={(e) => setNewPassword(e.target.value)} className="w-full p-2 border rounded pr-10" />
                      <button onClick={() => setShowNewPassword(!showNewPassword)} className="absolute right-2 top-2 p-1 text-gray-500 hover:text-gray-700">
                        {showNewPassword ? (
                          <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M13.875 18.825A10.05 10.05 0 0112 19c-4.478 0-8.268-2.943-9.543-7a9.97 9.97 0 011.563-3.029m5.858.908a3 3 0 114.243 4.243M9.878 9.878l4.242 4.242M9.88 9.88l-3.29-3.29m7.532 7.532l3.29 3.29M3 3l3.59 3.59m0 0A9.953 9.953 0 0112 5c4.478 0 8.268 2.943 9.543 7a10.025 10.025 0 01-4.132 5.411m0 0L21 21"></path></svg>
                        ) : (
                          <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"></path></svg>
                        )}
                      </button>
                    </div>
                    <button onClick={handleChangePassword} className="w-full p-2 bg-blue-500 text-white rounded hover:bg-blue-600">Update Password</button>
                  </div>
                </div>

                {/* Friend Requests */}
                <div>
                  <h3 className="text-lg font-medium mb-2">Friend Requests ({friendRequests.length})</h3>
                  {friendRequests.length > 0 ? (
                    <ul className="space-y-2 max-h-60 overflow-y-auto">
                      {friendRequests.map(request => (
                        <li key={request.uid} className="flex justify-between items-center p-2 bg-gray-50 rounded">
                          <span>{request.firstName} {request.lastName} ({request.username})</span>
                          <div className="flex space-x-2">
                            <button onClick={() => acceptFriendRequest(request.uid, request.username)} className="p-1 text-green-500 hover:text-green-600">Accept</button>
                            <button onClick={() => declineFriendRequest(request.uid)} className="p-1 text-red-500 hover:text-red-600">Decline</button>
                          </div>
                        </li>
                      ))}
                    </ul>
                  ) : (
                    <p className="text-gray-500">No pending friend requests.</p>
                  )}
                </div>

                {/* Friends Settings */}
                <div>
                  <h3 className="text-lg font-medium mb-2">Friends Settings</h3>
                  <div className="space-y-4">
                    <div className="flex space-x-2">
                      <input type="text" placeholder="Friend's Username" value={newFriend} onChange={(e) => setNewFriend(e.target.value)} className="flex-1 p-2 border rounded" />
                      <button onClick={sendFriendRequest} className="p-2 bg-green-500 text-white rounded hover:bg-green-600">Send Request</button>
                    </div>
                    <ul className="space-y-2 max-h-60 overflow-y-auto">
                      {friends.map(friend => (
                        <li key={friend.uid} className="flex justify-between items-center p-2 bg-gray-50 rounded">
                          <span>{friend.firstName} {friend.lastName} ({friend.name})</span>
                          <div className="flex space-x-2">
                            <button onClick={() => setShowDeleteFriendPopup({ uid: friend.uid, name: friend.name })} className="p-1 text-red-500 hover:text-red-600">
                              <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                            </button>
                          </div>
                        </li>
                      ))}
                    </ul>
                    {selectedFriend && (
                      <div className="mt-4">
                        <h3 className="text-lg font-medium mb-2">{selectedFriend.firstName} {selectedFriend.lastName} ({selectedFriend.name})'s Workouts</h3>
                        <ul className="space-y-2">{selectedFriend.workouts.map(workout => <li key={workout.id} className="p-2 bg-gray-50 rounded">{workout.type} - {workout.date}</li>)}</ul>
                        <button onClick={() => setSelectedFriend(null)} className="mt-4 p-2 bg-red-500 text-white rounded hover:bg-red-600">Close</button>
                      </div>
                    )}
                    {showDeleteFriendPopup && (
                      <div className="fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 backdrop-blur-sm">
                        <div className="bg-white p-6 rounded-lg shadow-lg max-w-md w-full">
                          <h3 className="text-lg font-semibold mb-4">Confirm Removal</h3>
                          <p className="mb-4">Are you sure you want to remove this friend?</p>
                          <div className="flex space-x-2">
                            <button onClick={() => removeFriend(showDeleteFriendPopup.uid, showDeleteFriendPopup.name)} className="flex-1 p-2 bg-red-500 text-white rounded hover:bg-red-600">Confirm</button>
                            <button onClick={() => setShowDeleteFriendPopup(null)} className="flex-1 p-2 bg-gray-300 text-black rounded hover:bg-gray-400">Cancel</button>
                          </div>
                        </div>
                      </div>
                    )}
                  </div>
                </div>

                {/* Exercises */}
                <div>
                  <h3 className="text-lg font-medium mb-2">Exercises</h3>
                  <ul className="space-y-2 max-h-60 overflow-y-auto">
                    {getUniqueWorkoutTypes(currentUserWorkouts).map(type => (
                      <li key={type} className="p-2 bg-gray-50 rounded cursor-pointer hover:bg-gray-100" onClick={() => setSelectedExercise(type)}>
                        {type}
                      </li>
                    ))}
                  </ul>
                </div>

                {/* Logout */}
                <div>
                  <button onClick={() => setShowLogoutPopup(true)} className="w-full p-2 bg-red-500 text-white rounded hover:bg-red-600">Logout</button>
                </div>
                {showLogoutPopup && (
                  <div className="fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 backdrop-blur-sm">
                    <div className="bg-white p-6 rounded-lg shadow-lg max-w-md w-full">
                      <h3 className="text-lg font-semibold mb-4">Confirm Logout</h3>
                      <p className="mb-4">Are you sure you want to log out?</p>
                      <div className="flex space-x-2">
                        <button onClick={handleLogout} className="flex-1 p-2 bg-red-500 text-white rounded hover:bg-red-600">Confirm Logout</button>
                        <button onClick={() => setShowLogoutPopup(false)} className="flex-1 p-2 bg-gray-300 text-black rounded hover:bg-gray-400">Cancel</button>
                      </div>
                    </div>
                  </div>
                )}
              </div>
            </div>
          )}
        </div>
      );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App/>);

  </script>
</body>
</html>